import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, matchPrecache  } from 'workbox-precaching';
import { registerRoute, setCatchHandler } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst, NetworkFirst } from 'workbox-strategies';
import {CacheableResponsePlugin} from 'workbox-cacheable-response';

/**
* disable workbox logs
*/
self.__WB_DISABLE_DEV_LOGS = true;


/**
 * Precache all the assets generated by build process.
 * Their URLs are injected into the manifest variable below.
 */
precacheAndRoute(self.__WB_MANIFEST);


/**
* caching resources for html/fonts/css/images/js 
*/
const HTML_CACHE = "ngh-html";
const API_CACHE = "ngh-api"
const JS_CACHE = "ngh-javascript";
const STYLE_CACHE = "ngh-stylesheets";
const IMAGE_CACHE = "ngh-images";
const FONT_CACHE = "ngh-fonts";


const filterRouteTobeCached = (request) => {
  const cacheablePaths = [
    '/catalog-service/ve',
    '/prod-olo-api/v1',
    '/agg/ve1/',
    '/locator-service/ve'
  ];
  return (
    request.method === 'GET' &&
    cacheablePaths.some(
      cacheablePath => request.url.indexOf(cacheablePath) !== -1
    )
  );
};

const filterImageRouteTobeCached = (request) => {
  const cacheablePaths = [
    '/jfl-discovery-ui/'
  ];
  return (
    request.method === 'GET' &&
    cacheablePaths.some(
      cacheablePath => request.url.indexOf(cacheablePath) !== -1
    )
  );
};

/** commented for now, can be uncommented if document need to be cached through sw */
// registerRoute(
//     ({request}) => request.destination === 'document',
//     new NetworkFirst({
//       cacheName: HTML_CACHE,
//       plugins: [
//         new CacheableResponsePlugin({
//           statuses: [0, 200],
//         }),
//         new ExpirationPlugin({
//           maxEntries: 10,
//         }),
//       ],
//     })
// );

/** commented for now, can be uncommented if api's need to be cached in sw */
// registerRoute(
//   ({request}) => filterRouteTobeCached(request),
//   new StaleWhileRevalidate({
//     // gets from cache and updates the cache in background from network
//     cacheName: API_CACHE,
//     plugins: [
//       new CacheableResponsePlugin({
//         statuses: [200]
//       })
//     ]
//   })
// );

registerRoute(
    ({request}) => request.destination === 'font',
    new StaleWhileRevalidate({
      cacheName: FONT_CACHE,
      plugins: [
        new CacheableResponsePlugin({
          statuses: [0, 200],
        }),
        new ExpirationPlugin({
          maxEntries: 15,
          maxAgeSeconds: 60 * 60 * 24 * 30 // 30 Days
        }),
      ],
    })
);
  
registerRoute(
    ({request}) => request.destination === 'style',
    new StaleWhileRevalidate({
      cacheName: STYLE_CACHE,
      plugins: [
        new CacheableResponsePlugin({
          statuses: [0, 200],
        }),
        new ExpirationPlugin({
          maxEntries: 15,
        }),
      ],
    })
);


registerRoute(
    ({request}) => request.destination === 'image' && filterImageRouteTobeCached(request),
    new CacheFirst({
      cacheName: IMAGE_CACHE,
      plugins: [
        new CacheableResponsePlugin({
          statuses: [0, 200],
        }),
        new ExpirationPlugin({
          maxEntries: 60,
          maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
        }),
      ],
    }),
);

registerRoute(
    ({request}) => request.destination === 'script',
    new StaleWhileRevalidate({
      cacheName: JS_CACHE,
      plugins: [
        new ExpirationPlugin({
          maxEntries: 15,
        }),
      ],
    })
);

// Document fallback, will be precached and shown as document fallback
setCatchHandler(async ({ event }) => {
  if (event.request.destination === 'document') {
    return matchPrecache('/offline.html');
  }
  return Response.error();
});


// When new SW is in 'waiting' state and user allows new sw tobe installed (through the prompt shown)
addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  } else if (event.data && event.data.type === "CLIENTS_CLAIM") {
    clientsClaim();
  }
});


